// ELEC2645 Unit 3 Joystick Game 

// These are the header files that include the necessary declarations for the functions and peripherals used
// e.g. HAL (Hardware Abstraction Layer) functions, USART (serial communication), GPIO (general-purpose input/output)
// Here we incude an extra header for the ADC (analog to digital converter) peripheral since we are using it for joystick reading
// We also include the RNG peripheral to give us better random number generation than the default rand()
// These are auto-generated by STM32CubeMX when you set up the project and we do not need to modify them

#include "main.h"
#include "adc.h"
#include "stm32l4xx_hal_adc.h"
#include "usart.h"
#include "gpio.h"
#include "adc.h"
#include "rng.h"


// AUTO-GENERATED STM32 FUNCTION PROTOTYPES - DO NOT EDIT
void SystemClock_Config(void); // setups the system clock
void PeriphCommonClock_Config(void); // setups the peripheral clocks i.e. ADC, RNG etc.


// These are header files needed for this specific project written by us

#include "Joystick.h" // include the Joystick driver functions
#include "LCD.h" // include the LCD driver functions

#include <math.h> // for sqrtf, atan2f, etc.
#include <stdint.h> // for uint8_t etc. (already included in LCD.h but good practice to include if using uint8_t etc.)
#include <stdio.h> // for printf, sprintf etc.


// ===== UTILITY FUNCTIONS =====
int _write(int file, char *ptr, int len) {
  // added -u _printf_float in CMakeLists.txt to enable floating point support in printf
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}


/**
 * @brief Generate random number in range [0, max]
 * This function uses the RNG peripheral which returns a pseudorandom number
 * which is more random than the standard library rand() function.
 */
static uint16_t Random_U16(uint16_t max)
{
  uint32_t rnd = 0;
  HAL_RNG_GenerateRandomNumber(&hrng, &rnd);
  return (uint16_t)(rnd % max);
}


// ===== GAME FUNCTION PROTOTYPES =====
uint8_t Circles_Overlap(uint16_t x1, uint16_t y1, uint16_t r1,
                        uint16_t x2, uint16_t y2, uint16_t r2);

void Place_Target(uint8_t index,
                  uint16_t *target_x,
                  uint16_t *target_y,
                  uint16_t player_x,
                  uint16_t player_y);


// LCD display dimensions
#define LCD_WIDTH 240
#define LCD_HEIGHT 240
#define PLAY_AREA_Y0 20  // Leave space at top for title

// Player and target properties
#define PLAYER_RADIUS 5
#define TARGET_RADIUS 4
#define TARGET_COUNT 5

// Movement parameters
#define MOVE_SPEED 3      // Pixels to move per update
#define MOVE_DELAY_MS 50  // Milliseconds between movement updates


/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
  /* Configure the system clock */
  SystemClock_Config();
  /* Configure the peripherals common clocks */
  PeriphCommonClock_Config();


  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_RNG_Init();
  MX_USART2_UART_Init();

 // Initialize LCD
  ST7789V2_cfg_t cfg0 = {
    .setup_done = 0,
    .spi = SPI2,
    .RST = {.port = GPIOB, .pin = GPIO_PIN_2},
    .BL = {.port = GPIOB, .pin = GPIO_PIN_1},
    .DC = {.port = GPIOB, .pin = GPIO_PIN_11},
    .CS = {.port = GPIOB, .pin = GPIO_PIN_12},
    .MOSI = {.port = GPIOB, .pin = GPIO_PIN_15},
    .SCLK = {.port = GPIOB, .pin = GPIO_PIN_13},
    .dma = {.instance = DMA1, .channel = DMA1_Channel5}
  };
  LCD_init(&cfg0);


  printf("Joystick game, let's go get those dots!...\n");

  // Configure joystick
  Joystick_cfg_t joystick_cfg = {
    .adc = &hadc1,
    .x_channel = ADC_CHANNEL_1, //A5 on Nucleo board
    .y_channel = ADC_CHANNEL_2, //A4 on Nucleo board
    .sampling_time = ADC_SAMPLETIME_47CYCLES_5,
    .center_x = JOYSTICK_DEFAULT_CENTER_X,
    .center_y = JOYSTICK_DEFAULT_CENTER_Y,
    .deadzone = JOYSTICK_DEADZONE,
    .setup_done = 0
  };
  
  // Data structure to hold joystick readings
  Joystick_t joystick_data;
  
  // Initialize joystick ADC
  Joystick_Init(&joystick_cfg);
  
  // Optional: Calibrate joystick (comment out if joystick should be in center position at startup)
  printf("Calibrating joystick - keep it centered...\n");
  Joystick_Calibrate(&joystick_cfg);
  printf("Calibration complete: X=%d, Y=%d\n", joystick_cfg.center_x, joystick_cfg.center_y);

  LCD_Fill_Buffer(0);
  LCD_printString("Joystick Collect", 0, 0, 1, 2);

  // Initialize player at center of screen
  uint16_t player_x = LCD_WIDTH / 2;
  uint16_t player_y = LCD_HEIGHT / 2;

  // Arrays to store target positions
  uint16_t target_x[TARGET_COUNT] = {0};
  uint16_t target_y[TARGET_COUNT] = {0};

  // Spawn initial targets
  for (uint8_t i = 0; i < TARGET_COUNT; i++)
  {
    Place_Target(i, target_x, target_y, player_x, player_y);
  }

  // Draw player
  LCD_Draw_Circle(player_x, player_y, PLAYER_RADIUS, 2, 1);
  LCD_Refresh(&cfg0);

  uint32_t last_move_tick = HAL_GetTick();
  uint16_t prev_player_x = player_x;
  uint16_t prev_player_y = player_y;

  
  /**
   * ========== MAIN GAME LOOP ==========
   * 
   * This loop runs continuously and implements the core game mechanics:
   * 
   * 1) INPUT: Read joystick position and determine direction
   * 2) MOVEMENT: Update player pixel position based on joystick direction (with rate limiting)
   * 3) RENDERING: Erase old player position, draw new position on screen
   * 4) COLLISION: Check if player overlaps any targets using circle collision detection
   * 5) DISPLAY: Refresh the LCD to show all updates
   * 
   * The movement is smooth and pixel-based - the player moves MOVE_SPEED pixels
   * at a time in the joystick direction. Movement is rate-limited to MOVE_DELAY_MS
   * to control game speed. Students can experiment with using joystick magnitude
   * to create variable speed movement.
   */
  while (1)
  {
    // ===== STEP 1: Read Joystick Input =====
    Joystick_Read(&joystick_cfg, &joystick_data);

    // ===== STEP 2: Player Movement (Rate-Limited) =====
    // Only allow movement every MOVE_DELAY_MS milliseconds to control game speed
    uint32_t now = HAL_GetTick();
    if ((now - last_move_tick) >= MOVE_DELAY_MS && joystick_data.direction != CENTRE)
    {
      // Calculate movement delta based on joystick direction
      // dx/dy represent pixel movement in X and Y directions
      int16_t dx = 0;
      int16_t dy = 0;

      switch (joystick_data.direction)
      {
        case N:  dy = -MOVE_SPEED; break;
        case NE: dy = -MOVE_SPEED; dx =  MOVE_SPEED; break;
        case E:  dx =  MOVE_SPEED; break;
        case SE: dy =  MOVE_SPEED; dx =  MOVE_SPEED; break;
        case S:  dy =  MOVE_SPEED; break;
        case SW: dy =  MOVE_SPEED; dx = -MOVE_SPEED; break;
        case W:  dx = -MOVE_SPEED; break;
        case NW: dy = -MOVE_SPEED; dx = -MOVE_SPEED; break;
        default: break;
      }

      // Apply movement if joystick is deflected
      if (dx != 0 || dy != 0)
      {
        int32_t new_x = (int32_t)player_x + dx;
        int32_t new_y = (int32_t)player_y + dy;

        // Clamp position to screen boundaries (prevent player from leaving the display)
        // Keep player radius away from edges so the full circle stays visible
        if (new_x < PLAYER_RADIUS) new_x = PLAYER_RADIUS;
        if (new_x >= (LCD_WIDTH - PLAYER_RADIUS)) new_x = LCD_WIDTH - PLAYER_RADIUS - 1;
        if (new_y < (PLAY_AREA_Y0 + PLAYER_RADIUS)) new_y = PLAY_AREA_Y0 + PLAYER_RADIUS;
        if (new_y >= (LCD_HEIGHT - PLAYER_RADIUS)) new_y = LCD_HEIGHT - PLAYER_RADIUS - 1;

        player_x = (uint16_t)new_x;
        player_y = (uint16_t)new_y;
      }

      last_move_tick = now;
    }

    // ===== STEP 3: Render Player Movement =====
    // Only redraw if player actually moved (avoids unnecessary LCD operations)
    if (player_x != prev_player_x || player_y != prev_player_y)
    {
      // Erase player at old position (draw circle in background color)
      LCD_Draw_Circle(prev_player_x, prev_player_y, PLAYER_RADIUS, 0, 1);
      // Draw player at new position (draw circle in player color)
      LCD_Draw_Circle(player_x, player_y, PLAYER_RADIUS, 2, 1);

      prev_player_x = player_x;
      prev_player_y = player_y;
    }

    // ===== STEP 4: Collision Detection =====
    // Check if player circle overlaps with any target circles
    for (uint8_t i = 0; i < TARGET_COUNT; i++)
    {
      // Circle overlap collision: check if circles touch or overlap
      // Two circles collide when distance between centers < sum of radii
      if (Circles_Overlap(player_x, player_y, PLAYER_RADIUS, 
                          target_x[i], target_y[i], TARGET_RADIUS))
      {
        // Target collected! Erase from screen
        LCD_Draw_Circle(target_x[i], target_y[i], TARGET_RADIUS, 0, 1);

        // ===== STUDENT TODO =====
        // 1) Increment a score counter here.
        // 2) Spawn a new target by calling:
        //    Place_Target(i, target_x, target_y, player_x, player_y);
        // ========================

      
      }
    }

    // ===== STEP 5: Update Display =====
    // Transfer the frame buffer to the LCD hardware (makes all draws visible)
    LCD_Refresh(&cfg0);

  }
  return 0;
}


// ===== FUNCTION DEFINITIONS =====

/**
 * @brief Check if two circles overlap (for collision detection)
 * 
 * Two circles collide when the distance between their centers is less than
 * the sum of their radii. This function calculates the squared distance to
 * avoid expensive sqrt() operations - we compare squared distances instead.
 * 
 * @param x1, y1 Center coordinates of first circle
 * @param x2, y2 Center coordinates of second circle
 * @param r1, r2 Radii of the two circles
 * @return 1 if circles overlap, 0 otherwise
 */
uint8_t Circles_Overlap(uint16_t x1, uint16_t y1, uint16_t r1,
                        uint16_t x2, uint16_t y2, uint16_t r2)
{
  int32_t dx = (int32_t)x2 - (int32_t)x1;
  int32_t dy = (int32_t)y2 - (int32_t)y1;
  int32_t dist_squared = (dx * dx) + (dy * dy);
  int32_t radii_sum = r1 + r2;
  int32_t radii_sum_squared = radii_sum * radii_sum;
  
  return (dist_squared <= radii_sum_squared) ? 1 : 0;
}

/**
 * @brief Place a target at a random screen location that doesn't collide with player or other targets
 * 
 * This function uses a trial-and-error approach to find a valid spawn location:
 * 1) Generate random X/Y pixel coordinates within screen bounds
 * 2) Check if the location collides with the player using circle overlap detection
 * 3) Check if the location collides with any other targets
 * 4) If no collision, place the target and draw it on screen
 * 5) If collision detected, try again (up to 100 attempts)
 * 
 * The collision checking uses circle overlap: two circles collide if the distance
 * between their centers is less than the sum of their radii. This creates smooth,
 * natural-feeling collisions rather than harsh grid-based detection.
 * 
 * @param index Which target slot (0 to TARGET_COUNT-1) to place
 * @param target_x Array holding X pixel positions of all targets
 * @param target_y Array holding Y pixel positions of all targets
 * @param player_x Current player X position (to avoid spawning on player)
 * @param player_y Current player Y position
 */
void Place_Target(uint8_t index,
                  uint16_t *target_x,
                  uint16_t *target_y,
                  uint16_t player_x,
                  uint16_t player_y)
{
  uint8_t tries = 0;
  const uint16_t min_spacing = (PLAYER_RADIUS + TARGET_RADIUS) * 2;  // Minimum distance from player/targets

  while (tries < 100)
  {
    // Generate random position within play area, with margins for the target radius
    uint16_t x = Random_U16(LCD_WIDTH - 2 * TARGET_RADIUS) + TARGET_RADIUS;
    uint16_t y = Random_U16(LCD_HEIGHT - PLAY_AREA_Y0 - 2 * TARGET_RADIUS) + PLAY_AREA_Y0 + TARGET_RADIUS;

    // Check collision with player
    uint8_t collision = Circles_Overlap(x, y, min_spacing / 2, player_x, player_y, PLAYER_RADIUS);
    
    // Check collision with other targets
    if (!collision)
    {
      for (uint8_t i = 0; i < TARGET_COUNT; i++)
      {
        if (i == index)
        {
          continue;
        }

        if (Circles_Overlap(x, y, TARGET_RADIUS, target_x[i], target_y[i], TARGET_RADIUS))
        {
          collision = 1;
          break;
        }
      }
    }

    if (!collision)
    {
      target_x[index] = x;
      target_y[index] = y;

      LCD_Draw_Circle(x, y, TARGET_RADIUS, 6, 1);
      return;
    }

    tries++;
  }
}


// ==== AUTO-GENERATED STM32 FUNCTIONS ====


// ==== AUTO-GENERATED STM32 FUNCTIONS ====
// This is auto generated by STM32CubeMX, luckily we can just leave it here we dont need to understand it
//
// DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING! 


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_ADC;
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSI;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 8;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}



/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
